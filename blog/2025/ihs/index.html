<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> How to implicit hitting set | Konstantin Sidorov </title> <meta name="author" content="Konstantin Sidorov"> <meta name="description" content="A tour of implicit hitting set workflow and applications"> <meta name="keywords" content="academic-website, portfolio-website, optimization"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <script src="https://d3js.org/d3.v7.min.js"></script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.css" integrity="sha256-uRX+PiRTR4ysKFRCykT8HLuRCub26LgXJZym3Yeom1c=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/pixelated.favicon.png?dc8e6ab22cdffb4d87d0273ecb75e580"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://www.ksidorov.com/blog/2025/ihs/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Konstantin Sidorov </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/education/">education </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">How to implicit hitting set</h1> <p class="post-meta"> Created in August 08, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/ihs"> <i class="fa-solid fa-hashtag fa-sm"></i> ihs</a>   <a href="/blog/tag/optimization"> <i class="fa-solid fa-hashtag fa-sm"></i> optimization</a>   ·   <a href="/blog/category/techniques"> <i class="fa-solid fa-tag fa-sm"></i> techniques</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>A while ago, a colleague of mine has presented a paper on <a href="https://arxiv.org/abs/2412.11954" rel="external nofollow noopener" target="_blank">minimum-size decision trees</a>, and we started discussing their lower bounding strategies. At a certain point, we had the conversation that went approximately like this:<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></p> <blockquote> <p>— So, they [authors of the paper] employ a few pruning rules, all of them corresponding to some set cover problem.<br> — Wait, we already played these games:) I am pretty sure we have seen <strong>somewhere</strong> a strategy for solving with set covering.<br> — Of course we did, it is a common approach to solving MaxSAT problems.</p> </blockquote> <p>After we worked through the paper, we recollected a few more applications of this idea from previous seminars—which is a broad strategy of using <em>implicit hitting sets</em>. While that specific conversation eventually petered out, it got me thinking: for such a conceptually clear idea with so many ways to <em>apply</em> it, there are precious few resources to <em>learn</em> it! So, today, I would like to materialize the conversations I had into what I hope will be a clear explanation of how to implicit hitting set.</p> <h2 id="a-motivating-example-solving-knapsack-with-ihs">A motivating example: solving knapsack with IHS</h2> <p>Implicit hitting sets is a rich idea that generalizes to various NP (and even to some beyond-NP) problems. But first, let’s start with something much simpler than decision trees: <em>the 0—1 knapsack problem</em>. As a refresher, in this problem, given a set of items with weights and values, you have to select a subset of items such that:</p> <ul> <li>the total weight does not exceed the knapsack’s capacity,</li> <li>and the total value is maximized.</li> </ul> <p>There are many ways to solve this problem, but for now, we will try doing it by <em>trial and error</em>. For example, let’s try solving the following problem (capacity is 6 units of weight):</p> <table> <thead> <tr> <th style="text-align: left"><strong>Item</strong></th> <th style="text-align: left"><strong>Weight</strong></th> <th style="text-align: left"><strong>Value</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: left">A</td> <td style="text-align: left">4</td> <td style="text-align: left">5</td> </tr> <tr> <td style="text-align: left">B</td> <td style="text-align: left">2</td> <td style="text-align: left">4</td> </tr> <tr> <td style="text-align: left">C</td> <td style="text-align: left">5</td> <td style="text-align: left">8</td> </tr> </tbody> </table> <p>We want to get as much value as possible out of this. In this problem, you would be justified to explore valid solutions in some manner that goes from one solution to another, better one. What if we won’t try to build a solution from scratch, but instead asked: “<em>What went wrong last time?</em>” That’s the idea behind implicit hitting sets: it is a dual search approach that solves problems by repeatedly refining its guesses based on counterexamples.</p> <p>Back to our example; without any extra information, we can try being greedy:</p> <blockquote> <p>Would not it be great to take all three items? We can get 17 units of value.</p> </blockquote> <p>Unfortunately, no.</p> <blockquote> <p>…but why?</p> </blockquote> <p>Well, because you cannot take eleven units of weight; you only have six! In fact, <strong>you cannot even take B and C</strong> together.</p> <blockquote> <p>Too bad, but good to know that B and C are incompatible. Can I at least take A and C then? 13 units of value are also good.</p> </blockquote> <p>Still no, but I know what you will ask me; <strong>please don’t take A and C again.</strong></p> <blockquote> <p>Hm, so I have two options now. I can keep C, but now I cannot take anything else. I can drop C; would it be good now to take A and B?</p> </blockquote> <p>Good job. Enough reading, though; try this logic for yourself! The interactive demo below provides you with an implementation for that; you are also welcome to play around with various conflict choices (which are on you to make). What is the smallest collection of conflicts you need to build en route to the optimal solution?</p> <hr> <style>.bg-danger-mild{background-color:#de474b}.bg-success-mild{background-color:#138a33}</style> <p> <a class="btn btn-primary" data-toggle="collapse" href="#ihsDemo" role="button" aria-expanded="false" aria-controls="ihsDemo" id="toggleIhsBtnTop"> Show the IHS knapsack explorer demo </a> </p> <div class="collapse" id="ihsDemo"> <div class="card card-body"> <h2>Demo: IHS knapsack explorer</h2> <p>Capacity: <strong id="capacity"></strong></p> <div class="row"> <div class="col-md-6 mb-3" id="item-table"></div> <div class="col-md-6 mb-3" id="conflicts"></div> </div> <div class="mb-3"> <button id="reset-button" class="btn btn-secondary">Start over</button> </div> <h3>Item subsets</h3> <div id="conflict-picker"></div> <div id="results"></div> </div> </div> <p> <a class="btn btn-primary" data-toggle="collapse" href="#ihsDemo" role="button" aria-expanded="false" aria-controls="ihsDemo" id="toggleIhsBtnBot" style="display: none"> Show the IHS knapsack explorer demo </a> </p> <script>function powerset(e){return e.reduce((e,t)=>e.concat(e.map(e=>[...e,t])),[[]])}function blocker(e){return conflicts.find(t=>t.every(t=>e.map(e=>e.id).includes(t)))}function evaluate(e){const t=e.reduce((e,t)=>e+t.weight,0);return{weight:t,value:e.reduce((e,t)=>e+t.value,0),feasible:t<=capacity,blockedBy:blocker(e)}}function renderTable(){d3.select("#capacity").text(capacity);const e=d3.select("#item-table").html("").append("table").attr("class","table table-bordered");e.append("thead").append("tr").selectAll("th").data(["Item","Weight","Value"]).enter().append("th").text(e=>e);const t=e.append("tbody").selectAll("tr").data(items).enter().append("tr");t.append("td").text(e=>e.id),t.append("td").text(e=>e.weight),t.append("td").text(e=>e.value)}function renderConflictPicker(e){function t(){const{weight:e}=evaluate(l);e<=capacity?a.text(`Current weight: ${e}; not overweight yet!`):a.text(`Current weight: ${e}`),s.attr("disabled",e<=capacity||null)}const n=d3.select("#conflict-picker").html("").append("div").attr("class","card card-body mt-4");n.append("p").text("\ud83d\udca5 Overweight subset detected. Uncheck items to reduce weight:");let l=[...e];const c=n.append("div").attr("class","form-group form-check form-check-inline").selectAll("label").data(e).enter().append("label").attr("class","form-check-label mr-3");c.append("input").attr("type","checkbox").attr("class","form-check-input").attr("checked",!0).on("change",function(e,n){this.checked?l.push(n):l=l.filter(e=>e!==n),t()}),c.append("span").text(e=>e.id);const a=n.append("p").attr("id","weight-display").attr("class","small mt-2"),s=n.append("button").attr("id","confirm-conflict").attr("class","btn btn-primary btn-sm mt-2").text("Add a conflicting set of items").on("click",function(){evaluate(l).weight>capacity&&(conflicts.push(l.map(e=>e.id)),renderConflicts(),renderResults(),d3.select("#conflict-picker").html(""),autoIterate())});t()}function renderConflicts(){const e=d3.select("#conflicts").html("");if(e.append("h5").text("Conflict sets of items"),0===conflicts.length)return void e.append("p").attr("class","text-muted").text("No conflicts yet.");const t=e.append("ul").attr("class","pl-3");conflicts.forEach(e=>{t.append("li").text(`{${e.join(", ")}}`)})}function renderResults(){const e=powerset(items).map(e=>({subset:e,...evaluate(e)}));e.sort((e,t)=>t.value-e.value);const t=e.filter(e=>e.blockedBy===undefined).reduce((e,t)=>t.value>e.value?t:e,{value:-1}),n=d3.select("#results").html("");t&&t.feasible?n.append("p").attr("class","text-success font-weight-bold mt-2").text(`\ud83c\udf89 Optimal subset: {${t.subset.map(e=>e.id).join(", ")}}`):(n.append("p").attr("class","text-danger font-weight-bold mt-2").text("\u26a0\ufe0f Not a feasible subset yet; please choose a conflicting set of items."),renderConflictPicker(t.subset)),n.selectAll("div.subset").data(e).enter().append("div").attr("class",e=>{let n="p-2 mb-1 rounded border ";return e.blockedBy!==undefined?n+="bg-muted":(n+="text-light ",e.feasible?n+="bg-success-mild ":n+="bg-danger-mild ",e.value===t.value&&(n+=" font-weight-bold"),n)}).attr("style",e=>e.blockedBy===undefined?null:"text-decoration: line-through").text(e=>{return`{${e.subset.map(e=>e.id).join(", ")}} \u2192 weight=${e.weight}, value=${e.value}`})}function autoIterate(){const e=powerset(items).map(e=>({subset:e,...evaluate(e)})).filter(e=>e.blockedBy===undefined).reduce((e,t)=>t.value>e.value?t:e,{value:-1});e.feasible||renderConflictPicker(e.subset)}function resetAll(){conflicts=[],d3.select("#conflict-picker").html(""),renderConflicts(),renderResults()}document.addEventListener("DOMContentLoaded",function(){var e=document.getElementById("toggleIhsBtnTop"),t=document.getElementById("toggleIhsBtnBot");document.getElementById("ihsDemo");$("#ihsDemo").on("shown.bs.collapse",function(){e.textContent="Hide the IHS knapsack explorer demo",t.style.display="",t.textContent="Hide the IHS knapsack explorer demo"}),$("#ihsDemo").on("hidden.bs.collapse",function(){e.textContent="Show the IHS knapsack explorer demo",t.style.display="none"})});const items=[{id:"A",weight:3,value:4},{id:"B",weight:4,value:5},{id:"C",weight:2,value:3},{id:"D",weight:5,value:8}],capacity=6;let conflicts=[];d3.select("#reset-button").on("click",resetAll),renderTable(),renderConflicts(),renderResults();</script> <hr> <h2 id="the-general-idea">The general idea</h2> <p>First, let’s have a look at what we have just done. In this approach to knapsack problem, we maintained the <em>conflict sets</em> and repeated the following:</p> <ol> <li>Find the best solution that avoid all known conflicts.</li> <li>Is it feasible? Then stop, because it is also optimal.</li> <li>By this point, our solution is infeasible; inspect the solution and extract a conflict out of it.</li> </ol> <p>And now the best part: <strong>this approach does not rely on anything knapsack-specific</strong>. All it requires is that:</p> <ul> <li>You can state the problem in terms of “valid” versus “invalid” configurations.</li> <li>Given an invalid configuration, you can extract a <em>conflict</em> out of it: a set of elements that cannot be added together.</li> <li>Given a <em>set</em> of invalid configurations, you can find the “largest” that avoids all conflicts.</li> </ul> <p>The “duality” comes from this loop: instead of searching over the space of solutions (primal) until you exhaust all of it, you instead explore the space of explanations (dual) until you know enough of it. This workflow is especially powerful when your problem has no compact formulation, but can provide you with counterexamples when you ask for it. You don’t need to model the whole thing up front — just keep learning what doesn’t work.</p> <p>Here is a graphical summary of this technique:</p> <p><img src="/assets/img/ihs.svg"></p> <p>You can also narrate it in the minimization form:</p> <ul> <li>You can state the problem in terms of “valid” versus “invalid” configurations. (same)</li> <li>Given an invalid configuration, you can extract a core out of it: a set of elements that cannot be removed together.</li> <li>Given a <em>set</em> of invalid configurations, you can find the “smallest” that covers all the cores.</li> </ul> <p>Given this workflow, if you can fit your problem in this scheme, you can also solve it: at least, all the ingredients are in place!</p> <blockquote> <p>But <strong>how</strong> can I apply this?</p> </blockquote> <h2 id="where-ihs-shows-up">Where IHS shows up</h2> <p>In more than a few domains, actually! To give a few examples:</p> <h3 id="optimization">Optimization</h3> <p>First, let’s consider one of the most cited success stories of the implicit hitting set: the MaxSAT problem <a class="citation" href="#10.1007/978-3-642-23786-7_19">(Davies and Bacchus 2011)</a>. The problem has the following structure: given \(m\) <em>clauses</em> with <em>weights</em> \(w_1, \dotsc, w_n &gt; 0\) over Boolean variables, find an assignment that <em>minimizes the weight of violated clauses</em>.<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">2</a></sup></p> <p>The problem structure suggest a natural conflict description: an unsatisfiable subset of the input clauses. (In SAT literature, this set is referred to as <em>core</em>.) That, in turn, suggests a way to extract conflicts: given a set of clauses that are supposed to be satisfied, feed it into a SAT solver; here is what can happen:</p> <ul> <li>The SAT solver returns a <em>satisfying</em> assignment: great, this is the optimal solution.</li> <li>The SAT solver returns an <em>UNSAT</em> verdict: then we request an UNSAT core of the formula and add it to the core set.</li> </ul> <p>Once we set up the same conflict-avoidant logic as in our knapsack example, we get the following IHS loop:</p> <ol> <li>Find the minimum-weight hitting set of all known cores.</li> <li>Construct a SAT formula from this hitting set and halt if the assignment is found.</li> <li>Recover an UNSAT core and add it to the core set; repeat.</li> </ol> <h3 id="model-debugging">Model debugging</h3> <p>Just like you can find the <em>largest satisfiable</em> set, you can also find the <em>smallest unsatisfiable</em> one. This is an important problem when you, for example, are debugging a constraint model that is unsatisfiable but should not be for some extra-modeling reasons (e.g., domain knowledge). More precisely, the problem, known as the <em>smallest minimal unsatisfiable set (MUS) problem</em>, is as follows: given \(m\) clauses<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">3</a></sup> \(\Omega = \{ \omega_1, \dotsc, \omega_m \}\) over Boolean variables, find its smallest unsatisfiable subset \(\Omega^* \subseteq \Omega\) <a class="citation" href="#10.1007/978-3-319-23219-5_13">(Ignatiev et al. 2015)</a> .</p> <p>With a few examples under the belt, the dual of this problem is clear:</p> <ul> <li>we need to avoid all <em>not</em> unsatisfiable subsets \(\Omega' \subset \Omega\),</li> <li>so any unsatisfiable set has to contain one of the clauses in a set \(C := \Omega \setminus \Omega'\) of <em>omitted</em> clauses. Any subset of clauses \(C\) with this property—discarding it leaves a satisfiable formula—is called a <em>correction</em> subset. If adding any further clause to \(C\) breaks this, like a reverse Jenga puzzle, then it is a <em>maximal correction set</em> (MCS).</li> </ul> <p>With that said, here is the IHS approach we get:</p> <ol> <li>Find the minimum-weight hitting set of all known MCSes.</li> <li>Construct a SAT formula from this hitting set and halt if a solver declares it UNSAT.<sup id="fnref:5"><a href="#fn:5" class="footnote" rel="footnote" role="doc-noteref">4</a></sup> </li> <li>Recover an MCS and add it to the set of known MCSes; repeat.</li> </ol> <h3 id="inferring-functional-dependencies">Inferring functional dependencies</h3> <p>You can also discover the IHS formulation for enumeration problems, rather than the ones of optimization. For a widely known example of such problem, consider the situation described in <a class="citation" href="#MANNILA199483">(Mannila and Räihä 1994)</a>: You have a relational table, for example, like <a href="https://commons.wikimedia.org/wiki/File:DVD_Rental_Query.png" rel="external nofollow noopener" target="_blank">this</a> one:</p> <table> <thead> <tr> <th style="text-align: left">Title</th> <th style="text-align: left">Release year</th> <th style="text-align: center">Length</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">West Lion</td> <td style="text-align: left">2006</td> <td style="text-align: center">159</td> </tr> <tr> <td style="text-align: left">Sassy Packer</td> <td style="text-align: left">2005</td> <td style="text-align: center">154</td> </tr> <tr> <td style="text-align: left">Jingle Sagebrush</td> <td style="text-align: left">2005</td> <td style="text-align: center">159</td> </tr> </tbody> </table> <p>Clearly, some of the columns are going to <em>functionally determine</em> the others; for example, if you know Title and Release year, you should know Length. However, not all of the functional dependencies are going to be “natural,” such as the relation (Length, Release year) → Title. Knowing the relations that hold in this table—even if not marked explicitly—can be helpful for all sorts of reasons:</p> <ul> <li> <em>Pattern mining</em>: knowing that some if-else pattern holds unconditionally on your dataset is as good as it gets, if you are looking for dependencies.</li> <li> <em>Database design</em>: if a relation has a valid functional dependency that does not correspond to some table key, making that dependency explicit is helpful for data integrity.</li> <li> <em>Query optimization</em>: similarly, if a query optimizer knows that some column is defined by other, it can leverage such an information to short-circuit some table joins or even avoid table lookups altogether <a class="citation" href="#10.1145/146931.146932">(Siegel, Sciore, and Salveter 1992)</a>.</li> </ul> <p>A good start would be to enumerate <em>all</em> such dependencies. Again, by IHS playbook, we need to determine the following:</p> <ol> <li>When \((a_1, \dotsc, a_n) \to b\) is <em>not</em> a functional relation? That would mean that the column \(b\) in some two rows \(p, q\) is indistinguishable from columns in \(a\), in other words, when \(p(a_1, \dotsc, a_n) = q(a_1, \dotsc, a_n)\) but \(p(b) \neq q(b)\) for some rows \(p, q\).</li> <li>How to define a conflict? Given the “witness” rows \(p\) and \(q\) and the dependent column \(b\), we cannot discard \((a_1, \dotsc, a_n)\) from the set \(\Omega\) of all columns (similarly to the MUS example above).</li> <li>How to trim a conflict? Similarly to before, try adding more columns to the left-hand side \((a_1, \dotsc, a_n)\) without ending up discriminating the rows \(p\) and \(q\); once this is no longer possible, we found the maximal non-functional left-hand side and minimal conflict.</li> <li>How do <em>valid</em> solutions look like? They should add one of the conflict columns for all conflicts discovered as described above.</li> </ol> <p>Well, that was a lot; here is a short summary to match problems with their IHS ingredients:</p> <table> <thead> <tr> <th style="text-align: left"><strong>Problem</strong></th> <th style="text-align: left"><strong>Conflict structure</strong></th> <th style="text-align: left"><strong>Conflict extraction</strong></th> <th style="text-align: left"><strong>Hitting set interpretation</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: left">MaxSAT</td> <td style="text-align: left">UNSAT core</td> <td style="text-align: left">SAT solver run</td> <td style="text-align: left">A subset of clauses avoiding all UNSAT cores</td> </tr> <tr> <td style="text-align: left">Smallest MUS</td> <td style="text-align: left">Minimal correcting subsets</td> <td style="text-align: left">“Grow” procedure (add clauses to MCS and call a SAT solver)</td> <td style="text-align: left">A subset of clauses that does not discard fully any MCS</td> </tr> <tr> <td style="text-align: left">Functional relation inference</td> <td style="text-align: left">Non-discriminating column sets</td> <td style="text-align: left">Pairwise row testing</td> <td style="text-align: left">A subset of columns that does not collate any pair of rows disagreeing on right-hand side</td> </tr> </tbody> </table> <h2 id="miscellaneous-tricks">Miscellaneous tricks</h2> <p>Of course, while this scheme is simple to describe, executing it <em>well</em> is not so simple. Effective implementations of the IHS workflow incorporate a variety of extra techniques; for example:</p> <p><strong>Conflict/core extraction heuristics</strong>. Better core extraction = fewer iterations. For example, one way to speed up MUS extraction is to observe that:</p> <ul> <li>MCSes not only state that some subset is invalid, but also <em>give an assignment</em> that has to be falsified by any MUS (which has not happened on the IHS iteration of interest);</li> <li>and similar assignments (e.g., the ones obtained by flipping one bit) could yield <em>different</em> MCSes. This technique is known as <em>model rotation</em> and, while not giving any formal guarantees, it is known to be helpful for MUS extraction <a class="citation" href="#10.1007/978-3-642-21581-0_14">(Marques-Silva and Lynce 2011)</a>.</li> </ul> <p><strong>Smarter hitting set solvers</strong>. Hitting set computation is NP-complete; even if it is easier than handling most of the problems here directly, it is still not trivial. Therefore, hitting set solvers also commonly employ:</p> <ul> <li>integer linear programming solvers to get high-quality relaxations <a class="citation" href="#10.1007/978-3-642-23786-7_19">(Davies and Bacchus 2011)</a>,</li> <li>greedy approximations for fast lower bounds <a class="citation" href="#staus2024wittyefficientsolvercomputing">(Staus et al. 2024)</a>,</li> <li>and adding domain-specific constraints to avoid exploring <em>clearly</em> infeasible hitting sets <a class="citation" href="#10.5555/3032027.3032040">(Saikko, Wallner, and Järvisalo 2016)</a>.</li> </ul> <h2 id="conclusion">Conclusion</h2> <p>IHS dualization elegantly delegates search (candidate generation) to explanation of infeasibility (conflict learning). As any other versatile idea, it has many names in other fields; here are a few:</p> <ul> <li> <em>conflict-driven clause learning</em> from SAT solving,</li> <li> <em>nogood learning</em> in constraint programming,</li> <li> <em>cutting plane</em> approaches in integer programming,</li> <li> <em>counterfactual explanations</em> in machine learning,</li> <li> <em>counter-example guided abstract refinement</em> in program synthesis.</li> </ul> <p>Implicit Hitting Set dualization is a unifying perspective for tackling hard problems. Whether you’re debugging a program, optimizing a Boolean formula, or solving a puzzle, <strong>if it is easier to diagnose non-solutions than to enumerate valid solutions, IHS is a tool you want to consider.</strong></p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:2"> <p>I do not recollect the conversation on a word-by-word level, so the source for the next block is “I made it up.” That said, I recollect that we <em>had</em> a discussion that back-referenced us from this paper to previous IHS applications. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:3"> <p>The more common problem definition also discriminates between <em>hard</em> clauses that have to be satisfied unconditionally, and <em>soft</em> clauses that can be violated for a penalty. However, it is equivalent to the text definition: just set all hard clause weights to a number larger than the sum of soft clause weights, and declare the problem UNSAT if any of hard clauses is violated in the optimal solution. In the blog text, I stick to the soft-only definition, as it makes the exposition of the approach more accessible. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:4"> <p>But it might as well be an arbitrary constraint, albeit with less space for domain-specific techniques for correcting set extraction. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:5"> <p>Yes, this is the exact opposite of the MaxSAT condition; this only makes sense given the duality between those two problems. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <h2>References</h2> <div class="publications"> <ol class="bibliography"> <li> <div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="10.1007/978-3-642-23786-7_19" class="col-sm-8"> <div class="title">Solving MAXSAT by Solving a Sequence of Simpler SAT Instances</div> <div class="author"> Jessica Davies, and Fahiem Bacchus </div> <div class="periodical"> <em>In Principles and Practice of Constraint Programming – CP 2011</em>, 2011 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://link.springer.com/chapter/10.1007/978-3-642-23786-7_19" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">HTML</a> </div> <div class="abstract hidden"> <p>Maxsat is an optimization version of Satisfiability aimed at finding a truth assignment that maximizes the satisfaction of the theory. The technique of solving a sequence of SAT decision problems has been quite successful for solving larger, more industrially focused Maxsat instances, particularly when only a small number of clauses need to be falsified. The SAT decision problems, however, become more and more complicated as the minimal number of clauses that must be falsified increases. This can significantly degrade the performance of the approach. This technique also has more difficulty with the important generalization where each clause is given a weight: the weights generate SAT decision problems that are harder for SAT solvers to solve. In this paper we introduce a new Maxsat algorithm that avoids these problems. Our algorithm also solves a sequence of SAT instances. However, these SAT instances are always simplifications of the initial Maxsat formula, and thus are relatively easy for modern SAT solvers. This is accomplished by moving all of the arithmetic reasoning into a separate hitting set problem which can then be solved with techniques better suited to numeric reasoning, e.g., techniques from mathematical programming. As a result the performance of our algorithm is unaffected by the addition of clause weights. Our algorithm can, however, require solving more SAT instances than previous approaches. Nevertheless, the approach is simpler than previous methods and displays superior performance on some benchmarks.</p> </div> </div> </div> </li> <li> <div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="10.1007/978-3-319-23219-5_13" class="col-sm-8"> <div class="title">Smallest MUS Extraction with Minimal Hitting Set Dualization</div> <div class="author"> Alexey Ignatiev, Alessandro Previti, Mark Liffiton, and <span class="more-authors" title="click to view 1 more author" onclick=" var element=$(this); element.attr('title', ''); var more_authors_text=element.text() == '1 more author' ? 'Joao Marques-Silva' : '1 more author'; var cursorPosition=0; var textAdder=setInterval(function(){ element.html(more_authors_text.substring(0, cursorPosition + 1)); if (++cursorPosition == more_authors_text.length){ clearInterval(textAdder); } }, '10'); ">1 more author</span> </div> <div class="periodical"> <em>In Principles and Practice of Constraint Programming</em>, 2015 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://link.springer.com/chapter/10.1007/978-3-319-23219-5_13" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">HTML</a> <a href="https://alexeyignatiev.github.io/assets/pdf/iplms-cp15-preprint.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">PDF</a> </div> <div class="abstract hidden"> <p>Minimal explanations of infeasibility are of great interest in many domains. In propositional logic, these are referred to as Minimal Unsatisfiable Subsets (MUSes). An unsatisfiable formula can have multiple MUSes, some of which provide more insights than others. Different criteria can be considered in order to identify a good minimal explanation. Among these, the size of an MUS is arguably one of the most intuitive. Moreover, computing the smallest MUS (SMUS) finds several practical applications that include validating the quality of the MUSes computed by MUS extractors and finding equivalent subformulae of smallest size, among others. This paper develops a novel algorithm for computing a smallest MUS, and we show that it outperforms all the previous alternatives pushing the state of the art in SMUS solving. Although described in the context of propositional logic, the presented technique can also be applied to other constraint systems.</p> </div> </div> </div> </li> <li> <div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="MANNILA199483" class="col-sm-8"> <div class="title">Algorithms for inferring functional dependencies from relations</div> <div class="author"> Heikki Mannila, and Kari-Jouko Räihä </div> <div class="periodical"> <em>Data &amp; Knowledge Engineering</em>, 1994 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://www.sciencedirect.com/science/article/pii/0169023X9490023X" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">HTML</a> </div> <div class="abstract hidden"> <p>The dependency inference problem is to find a cover of the set of functional dependencies that hold in a given relation. The problem has applications in relational database design, in query optimization, and in artificial intelligence. The problem is exponential in the number of attributes. We develop two algorithms with better best case behavior than the simple one. One algorithm reduces the problem to computing the transversal of a hypergraph. The other is based on repeatedly sorting the relation with respect to a set of attributes.</p> </div> </div> </div> </li> <li> <div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="10.1145/146931.146932" class="col-sm-8"> <div class="title">A method for automatic rule derivation to support semantic query optimization</div> <div class="author"> Michael Siegel, Edward Sciore, and Sharon Salveter </div> <div class="periodical"> <em>ACM Trans. Database Syst.</em>, Dec 1992 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://doi.org/10.1145/146931.146932" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">HTML</a> </div> <div class="abstract hidden"> <p>The use of inference rules to support intelligent data processing is an increasingly important tool in many areas of computer science. In database systems, rules are used in semantic query optimization as a method for reducing query processing costs. The savings is dependent on the ability of experts to supply a set of useful rules and the ability of the optimizer to quickly find the appropriate transformations generated by these rules. Unfortunately, the most useful rules are not always those that would or could be specified by an expert. This paper describes the architecture of a system having two interrelated components: a combined conventional/semantic query optimizer, and an automatic rule deriver.Our automatic rule derivation method uses intermediate results from the optimization process to direct the search for learning new rules. Unlike a system employing only user-specified rules, a system with an automatic capability can derive rules that may be true only in the current state of the database and can modify the rule set to reflect changes in the database and its usage pattern.This system has been implemented as an extension of the EXODUS conventional query optimizer generator. We describe the implementation, and show how semantic query optimization is an extension of conventional optimization in this context.</p> </div> </div> </div> </li> <li> <div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="10.1007/978-3-642-21581-0_14" class="col-sm-8"> <div class="title">On Improving MUS Extraction Algorithms</div> <div class="author"> Joao Marques-Silva, and Ines Lynce </div> <div class="periodical"> <em>In Theory and Applications of Satisfiability Testing - SAT 2011</em>, Dec 2011 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://link.springer.com/chapter/10.1007/978-3-642-21581-0_14" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">HTML</a> <a href="https://satassociation.org/proceedings/SAT11/papers/SAT2011-page-156.pdf" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">PDF</a> </div> <div class="abstract hidden"> <p>Minimally Unsatisfiable Subformulas (MUS) find a wide range of practical applications, including product configuration, knowledge-based validation, and hardware and software design and verification. MUSes also find application in recent Maximum Satisfiability algorithms and in CNF formula redundancy removal. Besides direct applications in Propositional Logic, algorithms for MUS extraction have been applied to more expressive logics. This paper proposes two algorithms for MUS extraction. The first algorithm is optimal in its class, meaning that it requires the smallest number of calls to a SAT solver. The second algorithm extends earlier work, but implements a number of new techniques. The resulting algorithms achieve significant performance gains with respect to state of the art MUS extraction algorithms.</p> </div> </div> </div> </li> <li> <div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="staus2024wittyefficientsolvercomputing" class="col-sm-8"> <div class="title">Witty: An Efficient Solver for Computing Minimum-Size Decision Trees</div> <div class="author"> Luca Pascal Staus, Christian Komusiewicz, Frank Sommer, and <span class="more-authors" title="click to view 1 more author" onclick=" var element=$(this); element.attr('title', ''); var more_authors_text=element.text() == '1 more author' ? 'Manuel Sorge' : '1 more author'; var cursorPosition=0; var textAdder=setInterval(function(){ element.html(more_authors_text.substring(0, cursorPosition + 1)); if (++cursorPosition == more_authors_text.length){ clearInterval(textAdder); } }, '10'); ">1 more author</span> </div> <div class="periodical"> Dec 2024 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://arxiv.org/abs/2412.11954" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">HTML</a> </div> <div class="abstract hidden"> <p>Decision trees are a classic model for summarizing and classifying data. To enhance interpretability and generalization properties, it has been proposed to favor small decision trees. Accordingly, in the minimum-size decision tree training problem (MSDT), the input is a set of training examples in \mathbbR^d with class labels and we aim to find a decision tree that classifies all training examples correctly and has a minimum number of nodes. MSDT is NP-hard and therefore presumably not solvable in polynomial time. Nevertheless, Komusiewicz et al. [ICML ’23] developed a promising algorithmic paradigm called witness trees which solves MSDT efficiently if the solution tree is small. In this work, we test this paradigm empirically. We provide an implementation, augment it with extensive heuristic improvements, and scrutinize it on standard benchmark instances. The augmentations achieve a mean 324-fold (median 84-fold) speedup over the naive implementation. Compared to the state of the art they achieve a mean 32-fold (median 7-fold) speedup over the dynamic programming based MurTree solver [Demirović et al., J. Mach. Learn. Res. ’22] and a mean 61-fold (median 25-fold) speedup over SAT-based implementations [Janota and Morgado, SAT ’20]. As a theoretical result we obtain an improved worst-case running-time bound for MSDT.</p> </div> </div> </div> </li> <li> <div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="10.5555/3032027.3032040" class="col-sm-8"> <div class="title">Implicit hitting set algorithms for reasoning beyond NP</div> <div class="author"> Paul Saikko, Johannes P. Wallner, and Matti Järvisalo </div> <div class="periodical"> <em>In Proceedings of the Fifteenth International Conference on Principles of Knowledge Representation and Reasoning</em>, Cape Town, South Africa, Dec 2016 </div> <div class="periodical"> </div> <div class="links"> <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a> <a href="https://dl.acm.org/doi/10.5555/3032027.3032040" class="btn btn-sm z-depth-0" role="button" rel="external nofollow noopener" target="_blank">HTML</a> </div> <div class="abstract hidden"> <p>Lifting a recent proposal by Moreno-Centeno and Karp, we propose a general framework for so-called implicit hitting set algorithms for reasoning beyond NP. The framework is motivated by empirically successful specific instantiations of the approach—based on interactions between a Boolean satisfiability (SAT) solver and an integer programming (IP) solver—in the context of maximum satisfiability (MaxSAT). The framework opens up opportunities for developing implicit hitting set algorithms for various important reasoning problems in KR by implementing domain-specific reasoning modules with SAT and IP solvers. We detail instantiations of the framework for the minimum satisfiability problem— as a natural dual of MaxSAT—and, as a central KR problem, for propositional abduction, covering the second level of the polynomial hierarchy. We show empirically that an implementation of the instantiation for propositional abduction surpasses the efficiency of an approach based on encoding and solving propositional abduction instances as disjunctive logic programming under answer set semantics. We also study key properties of the general framework.</p> </div> </div> </div> </li> </ol> </div> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> The content of this website is licensed under <a href="https://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">Creative Commons Attribution 4.0 International<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""></a> </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.js" integrity="sha256-4rppopQE9POKfukn2kEvhJ9Um25Cf6+IDVkARD0xh78=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script src="https://cdn.jsdelivr.net/npm/@iframe-resizer/parent@5.4.6"></script> <script>iframeResize({license:"GPLv3",log:"collapsed",waitForLoad:!0},".iframe-resize");</script> </body> </html>